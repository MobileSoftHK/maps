// This file is generated by
// ./scripts/lib/generate.dart

part of mapbox_gl_platform_interface;

abstract class Source {
  Map<String, dynamic> toJson();
}

class VectorSource implements Source {
  /// A URL to a TileJSON resource. Supported protocols are `http:`,
  /// `https:`, and `mapbox://<Tileset ID>`.
  ///
  /// Type: string
  final String? url;

  /// An array of one or more tile source URLs, as in the TileJSON spec.
  ///
  /// Type: array
  final List<String>? tiles;

  /// An array containing the longitude and latitude of the southwest and
  /// northeast corners of the source's bounding box in the following order:
  /// `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in
  /// a source, no tiles outside of the given bounds are requested by Mapbox
  /// GL.
  ///
  /// Type: array
  ///   default: [-180, -85.051129, 180, 85.051129]
  final List<double>? bounds;

  /// Influences the y direction of the tile coordinates. The
  /// global-mercator (aka Spherical Mercator) profile is assumed.
  ///
  /// Type: enum
  ///   default: xyz
  /// Options:
  ///   "xyz"
  ///      Slippy map tilenames scheme.
  ///   "tms"
  ///      OSGeo spec scheme.
  final String? scheme;

  /// Minimum zoom level for which tiles are available, as in the TileJSON
  /// spec.
  ///
  /// Type: number
  ///   default: 0
  final double? minzoom;

  /// Maximum zoom level for which tiles are available, as in the TileJSON
  /// spec. Data from tiles at the maxzoom are used when displaying the map
  /// at higher zoom levels.
  ///
  /// Type: number
  ///   default: 22
  final double? maxzoom;

  /// Contains an attribution to be displayed when the map is shown to a
  /// user.
  ///
  /// Type: string
  final String? attribution;

  /// A property to use as a feature id (for feature state). Either a
  /// property name, or an object of the form `{<sourceLayer>:
  /// <propertyName>}`. If specified as a string for a vector tile source,
  /// the same property is used across all its source layers.
  ///
  /// Type: promoteId
  final String? promoteId;

  const VectorSource({
    this.url,
    this.tiles,
    this.bounds = const [-180, -85.051129, 180, 85.051129],
    this.scheme = "xyz",
    this.minzoom = 0,
    this.maxzoom = 22,
    this.attribution,
    this.promoteId,
  });

  VectorSource copyWith(VectorSource changes) {
    return VectorSource(
      url: changes.url ?? url,
      tiles: changes.tiles ?? tiles,
      bounds: changes.bounds ?? bounds,
      scheme: changes.scheme ?? scheme,
      minzoom: changes.minzoom ?? minzoom,
      maxzoom: changes.maxzoom ?? maxzoom,
      attribution: changes.attribution ?? attribution,
      promoteId: changes.promoteId ?? promoteId,
    );
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> json = <String, dynamic>{};

    void addIfPresent(String fieldName, dynamic value) {
      if (value != null) {
        json[fieldName] = value;
      }
    }

    json["type"] = "vector";
    addIfPresent('url', url);
    addIfPresent('tiles', tiles);
    addIfPresent('bounds', bounds);
    addIfPresent('scheme', scheme);
    addIfPresent('minzoom', minzoom);
    addIfPresent('maxzoom', maxzoom);
    addIfPresent('attribution', attribution);
    addIfPresent('promoteId', promoteId);
    return json;
  }

  factory VectorSource.fromJson(Map<String, dynamic> json) {
    return VectorSource(
      url: json['url'],
      tiles: json['tiles'],
      bounds: json['bounds'],
      scheme: json['scheme'],
      minzoom: json['minzoom'],
      maxzoom: json['maxzoom'],
      attribution: json['attribution'],
      promoteId: json['promoteId'],
    );
  }
}

class RasterSource implements Source {
  /// A URL to a TileJSON resource. Supported protocols are `http:`,
  /// `https:`, and `mapbox://<Tileset ID>`.
  ///
  /// Type: string
  final String? url;

  /// An array of one or more tile source URLs, as in the TileJSON spec.
  ///
  /// Type: array
  final List<String>? tiles;

  /// An array containing the longitude and latitude of the southwest and
  /// northeast corners of the source's bounding box in the following order:
  /// `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in
  /// a source, no tiles outside of the given bounds are requested by Mapbox
  /// GL.
  ///
  /// Type: array
  ///   default: [-180, -85.051129, 180, 85.051129]
  final List<double>? bounds;

  /// Minimum zoom level for which tiles are available, as in the TileJSON
  /// spec.
  ///
  /// Type: number
  ///   default: 0
  final double? minzoom;

  /// Maximum zoom level for which tiles are available, as in the TileJSON
  /// spec. Data from tiles at the maxzoom are used when displaying the map
  /// at higher zoom levels.
  ///
  /// Type: number
  ///   default: 22
  final double? maxzoom;

  /// The minimum visual size to display tiles for this layer. Only
  /// configurable for raster layers.
  ///
  /// Type: number
  ///   default: 512
  final double? tileSize;

  /// Influences the y direction of the tile coordinates. The
  /// global-mercator (aka Spherical Mercator) profile is assumed.
  ///
  /// Type: enum
  ///   default: xyz
  /// Options:
  ///   "xyz"
  ///      Slippy map tilenames scheme.
  ///   "tms"
  ///      OSGeo spec scheme.
  final String? scheme;

  /// Contains an attribution to be displayed when the map is shown to a
  /// user.
  ///
  /// Type: string
  final String? attribution;

  const RasterSource({
    this.url,
    this.tiles,
    this.bounds = const [-180, -85.051129, 180, 85.051129],
    this.minzoom = 0,
    this.maxzoom = 22,
    this.tileSize = 512,
    this.scheme = "xyz",
    this.attribution,
  });

  RasterSource copyWith(RasterSource changes) {
    return RasterSource(
      url: changes.url ?? url,
      tiles: changes.tiles ?? tiles,
      bounds: changes.bounds ?? bounds,
      minzoom: changes.minzoom ?? minzoom,
      maxzoom: changes.maxzoom ?? maxzoom,
      tileSize: changes.tileSize ?? tileSize,
      scheme: changes.scheme ?? scheme,
      attribution: changes.attribution ?? attribution,
    );
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> json = <String, dynamic>{};

    void addIfPresent(String fieldName, dynamic value) {
      if (value != null) {
        json[fieldName] = value;
      }
    }

    json["type"] = "raster";
    addIfPresent('url', url);
    addIfPresent('tiles', tiles);
    addIfPresent('bounds', bounds);
    addIfPresent('minzoom', minzoom);
    addIfPresent('maxzoom', maxzoom);
    addIfPresent('tileSize', tileSize);
    addIfPresent('scheme', scheme);
    addIfPresent('attribution', attribution);
    return json;
  }

  factory RasterSource.fromJson(Map<String, dynamic> json) {
    return RasterSource(
      url: json['url'],
      tiles: json['tiles'],
      bounds: json['bounds'],
      minzoom: json['minzoom'],
      maxzoom: json['maxzoom'],
      tileSize: json['tileSize'],
      scheme: json['scheme'],
      attribution: json['attribution'],
    );
  }
}

class RasterDemSource implements Source {
  /// A URL to a TileJSON resource. Supported protocols are `http:`,
  /// `https:`, and `mapbox://<Tileset ID>`.
  ///
  /// Type: string
  final String? url;

  /// An array of one or more tile source URLs, as in the TileJSON spec.
  ///
  /// Type: array
  final List<String>? tiles;

  /// An array containing the longitude and latitude of the southwest and
  /// northeast corners of the source's bounding box in the following order:
  /// `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in
  /// a source, no tiles outside of the given bounds are requested by Mapbox
  /// GL.
  ///
  /// Type: array
  ///   default: [-180, -85.051129, 180, 85.051129]
  final List<double>? bounds;

  /// Minimum zoom level for which tiles are available, as in the TileJSON
  /// spec.
  ///
  /// Type: number
  ///   default: 0
  final double? minzoom;

  /// Maximum zoom level for which tiles are available, as in the TileJSON
  /// spec. Data from tiles at the maxzoom are used when displaying the map
  /// at higher zoom levels.
  ///
  /// Type: number
  ///   default: 22
  final double? maxzoom;

  /// The minimum visual size to display tiles for this layer. Only
  /// configurable for raster layers.
  ///
  /// Type: number
  ///   default: 512
  final double? tileSize;

  /// Contains an attribution to be displayed when the map is shown to a
  /// user.
  ///
  /// Type: string
  final String? attribution;

  /// The encoding used by this source. Mapbox Terrain RGB is used by
  /// default
  ///
  /// Type: enum
  ///   default: mapbox
  /// Options:
  ///   "terrarium"
  ///      Terrarium format PNG tiles. See
  ///      https://aws.amazon.com/es/public-datasets/terrain/ for more info.
  ///   "mapbox"
  ///      Mapbox Terrain RGB tiles. See
  ///      https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb
  ///      for more info.
  final String? encoding;

  const RasterDemSource({
    this.url,
    this.tiles,
    this.bounds = const [-180, -85.051129, 180, 85.051129],
    this.minzoom = 0,
    this.maxzoom = 22,
    this.tileSize = 512,
    this.attribution,
    this.encoding = "mapbox",
  });

  RasterDemSource copyWith(RasterDemSource changes) {
    return RasterDemSource(
      url: changes.url ?? url,
      tiles: changes.tiles ?? tiles,
      bounds: changes.bounds ?? bounds,
      minzoom: changes.minzoom ?? minzoom,
      maxzoom: changes.maxzoom ?? maxzoom,
      tileSize: changes.tileSize ?? tileSize,
      attribution: changes.attribution ?? attribution,
      encoding: changes.encoding ?? encoding,
    );
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> json = <String, dynamic>{};

    void addIfPresent(String fieldName, dynamic value) {
      if (value != null) {
        json[fieldName] = value;
      }
    }

    json["type"] = "raster_dem";
    addIfPresent('url', url);
    addIfPresent('tiles', tiles);
    addIfPresent('bounds', bounds);
    addIfPresent('minzoom', minzoom);
    addIfPresent('maxzoom', maxzoom);
    addIfPresent('tileSize', tileSize);
    addIfPresent('attribution', attribution);
    addIfPresent('encoding', encoding);
    return json;
  }

  factory RasterDemSource.fromJson(Map<String, dynamic> json) {
    return RasterDemSource(
      url: json['url'],
      tiles: json['tiles'],
      bounds: json['bounds'],
      minzoom: json['minzoom'],
      maxzoom: json['maxzoom'],
      tileSize: json['tileSize'],
      attribution: json['attribution'],
      encoding: json['encoding'],
    );
  }
}

class GeojsonSource implements Source {
  /// A URL to a GeoJSON file, or inline GeoJSON.
  ///
  /// Type: *
  final dynamic data;

  /// Maximum zoom level at which to create vector tiles (higher means
  /// greater detail at high zoom levels).
  ///
  /// Type: number
  ///   default: 18
  final double? maxzoom;

  /// Contains an attribution to be displayed when the map is shown to a
  /// user.
  ///
  /// Type: string
  final String? attribution;

  /// Size of the tile buffer on each side. A value of 0 produces no buffer.
  /// A value of 512 produces a buffer as wide as the tile itself. Larger
  /// values produce fewer rendering artifacts near tile edges and slower
  /// performance.
  ///
  /// Type: number
  ///   default: 128
  ///   minimum: 0
  ///   maximum: 512
  final double? buffer;

  /// Douglas-Peucker simplification tolerance (higher means simpler
  /// geometries and faster performance).
  ///
  /// Type: number
  ///   default: 0.375
  final double? tolerance;

  /// If the data is a collection of point features, setting this to true
  /// clusters the points by radius into groups. Cluster groups become new
  /// `Point` features in the source with additional properties:
  /// * `cluster` Is `true` if the point is a cluster
  /// * `cluster_id` A unqiue id for the cluster to be used in conjunction
  /// with the [cluster inspection
  /// methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)
  /// * `point_count` Number of original points grouped into this cluster
  /// * `point_count_abbreviated` An abbreviated point count
  ///
  /// Type: boolean
  ///   default: false
  final bool? cluster;

  /// Radius of each cluster if clustering is enabled. A value of 512
  /// indicates a radius equal to the width of a tile.
  ///
  /// Type: number
  ///   default: 50
  ///   minimum: 0
  final double? clusterRadius;

  /// Max zoom on which to cluster points if clustering is enabled. Defaults
  /// to one zoom less than maxzoom (so that last zoom features are not
  /// clustered).
  ///
  /// Type: number
  final double? clusterMaxZoom;

  /// An object defining custom properties on the generated clusters if
  /// clustering is enabled, aggregating values from clustered points. Has
  /// the form `{"property_name": [operator, map_expression]}`. `operator`
  /// is any expression function that accepts at least 2 operands (e.g.
  /// `"+"` or `"max"`) — it accumulates the property value from
  /// clusters/points the cluster contains; `map_expression` produces the
  /// value of a single point.Example: `{"sum": ["+", ["get",
  /// "scalerank"]]}`.For more advanced use cases, in place of `operator`,
  /// you can use a custom reduce expression that references a special
  /// `["accumulated"]` value, e.g.:`{"sum": [["+", ["accumulated"],
  /// ["get", "sum"]], ["get", "scalerank"]]}`
  ///
  /// Type: *
  final Map<String, dynamic>? clusterProperties;

  /// Whether to calculate line distance metrics. This is required for line
  /// layers that specify `line-gradient` values.
  ///
  /// Type: boolean
  ///   default: false
  final bool? lineMetrics;

  /// Whether to generate ids for the geojson features. When enabled, the
  /// `feature.id` property will be auto assigned based on its index in the
  /// `features` array, over-writing any previous values.
  ///
  /// Type: boolean
  ///   default: false
  final bool? generateId;

  /// A property to use as a feature id (for feature state). Either a
  /// property name, or an object of the form `{<sourceLayer>:
  /// <propertyName>}`.
  ///
  /// Type: promoteId
  final String? promoteId;

  const GeojsonSource({
    this.data,
    this.maxzoom = 18,
    this.attribution,
    this.buffer = 128,
    this.tolerance = 0.375,
    this.cluster = false,
    this.clusterRadius = 50,
    this.clusterMaxZoom,
    this.clusterProperties,
    this.lineMetrics = false,
    this.generateId = false,
    this.promoteId,
  });

  GeojsonSource copyWith(GeojsonSource changes) {
    return GeojsonSource(
      data: changes.data ?? data,
      maxzoom: changes.maxzoom ?? maxzoom,
      attribution: changes.attribution ?? attribution,
      buffer: changes.buffer ?? buffer,
      tolerance: changes.tolerance ?? tolerance,
      cluster: changes.cluster ?? cluster,
      clusterRadius: changes.clusterRadius ?? clusterRadius,
      clusterMaxZoom: changes.clusterMaxZoom ?? clusterMaxZoom,
      clusterProperties: changes.clusterProperties ?? clusterProperties,
      lineMetrics: changes.lineMetrics ?? lineMetrics,
      generateId: changes.generateId ?? generateId,
      promoteId: changes.promoteId ?? promoteId,
    );
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> json = <String, dynamic>{};

    void addIfPresent(String fieldName, dynamic value) {
      if (value != null) {
        json[fieldName] = value;
      }
    }

    json["type"] = "geojson";
    addIfPresent('data', data);
    addIfPresent('maxzoom', maxzoom);
    addIfPresent('attribution', attribution);
    addIfPresent('buffer', buffer);
    addIfPresent('tolerance', tolerance);
    addIfPresent('cluster', cluster);
    addIfPresent('clusterRadius', clusterRadius);
    addIfPresent('clusterMaxZoom', clusterMaxZoom);
    addIfPresent('clusterProperties', clusterProperties);
    addIfPresent('lineMetrics', lineMetrics);
    addIfPresent('generateId', generateId);
    addIfPresent('promoteId', promoteId);
    return json;
  }

  factory GeojsonSource.fromJson(Map<String, dynamic> json) {
    return GeojsonSource(
      data: json['data'],
      maxzoom: json['maxzoom'],
      attribution: json['attribution'],
      buffer: json['buffer'],
      tolerance: json['tolerance'],
      cluster: json['cluster'],
      clusterRadius: json['clusterRadius'],
      clusterMaxZoom: json['clusterMaxZoom'],
      clusterProperties: json['clusterProperties'],
      lineMetrics: json['lineMetrics'],
      generateId: json['generateId'],
      promoteId: json['promoteId'],
    );
  }
}

class VideoSource implements Source {
  /// URLs to video content in order of preferred format.
  ///
  /// Type: array
  final List<String>? urls;

  /// Corners of video specified in longitude, latitude pairs.
  ///
  /// Type: array
  final List? coordinates;

  const VideoSource({
    this.urls,
    this.coordinates,
  });

  VideoSource copyWith(VideoSource changes) {
    return VideoSource(
      urls: changes.urls ?? urls,
      coordinates: changes.coordinates ?? coordinates,
    );
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> json = <String, dynamic>{};

    void addIfPresent(String fieldName, dynamic value) {
      if (value != null) {
        json[fieldName] = value;
      }
    }

    json["type"] = "video";
    addIfPresent('urls', urls);
    addIfPresent('coordinates', coordinates);
    return json;
  }

  factory VideoSource.fromJson(Map<String, dynamic> json) {
    return VideoSource(
      urls: json['urls'],
      coordinates: json['coordinates'],
    );
  }
}

class ImageSource implements Source {
  /// URL that points to an image.
  ///
  /// Type: string
  final String? url;

  /// Corners of image specified in longitude, latitude pairs.
  ///
  /// Type: array
  final List? coordinates;

  const ImageSource({
    this.url,
    this.coordinates,
  });

  ImageSource copyWith(ImageSource changes) {
    return ImageSource(
      url: changes.url ?? url,
      coordinates: changes.coordinates ?? coordinates,
    );
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> json = <String, dynamic>{};

    void addIfPresent(String fieldName, dynamic value) {
      if (value != null) {
        json[fieldName] = value;
      }
    }

    json["type"] = "image";
    addIfPresent('url', url);
    addIfPresent('coordinates', coordinates);
    return json;
  }

  factory ImageSource.fromJson(Map<String, dynamic> json) {
    return ImageSource(
      url: json['url'],
      coordinates: json['coordinates'],
    );
  }
}
